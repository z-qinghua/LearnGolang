// @program:     LearnGo
// @file:        通道容量.go
// @create:      2022-10-24 16:34
// @description:

//正如我们看到的，每次往无缓冲通道发送数据会阻塞当前协程，这是因为我们还没有使用make 函数的第二个参数。
//这第二个参数代表通道缓冲区的容量。 默认情况下通道缓冲区容量为 0，被称为无缓冲通道。 向无缓冲通道发送的数据需要立即被读取。
//
//当缓冲区参数不是 0 的时候。协程将不会阻塞除非缓冲区被填满。
//当缓冲区满了之后，想要再往缓冲区发送数据只有等到有其他协程从缓冲区接收数据， (此时的发送协程是阻塞的).
//有一点需要注意，读缓冲区的操作是渴望式读取. 意味着一旦读操作开始它将读取缓冲区所有数据，直到缓冲区为空。
//原理上来说读操作的协程将不会阻塞直到缓冲区为空.

package main

import (
	"fmt"
)

func squares(c chan int) {
	//从通道读取数据时，会将数据取出
	for i := 1; i <= 3; i++ {
		num := <-c
		fmt.Println(num * num)
	}
}

func main() {
	fmt.Println("main() started")
	//创建带有缓冲区的channel，除非缓冲区满，
	//否则一直可以往缓冲区发送数据并且不会阻塞
	c := make(chan int, 3)

	go squares(c)

	for i := 1; i <= 3; i++ {
		c <- i
	}

	//for i := 1; i <= 4; i++ {
	//	c <- i
	//}

	fmt.Println("main() stopped")
}

//缓冲区没有溢出，主线程就不会阻塞，直接退出程序
//当主线程阻塞时，squares调度执行，并一次从缓冲区输出所有数据
